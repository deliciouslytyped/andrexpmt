package com.example.comp.util.logging

import ch.qos.logback.classic.Level
import ch.qos.logback.classic.spi.ILoggingEvent
import ch.qos.logback.core.AppenderBase
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.asSharedFlow

//TODO there's some confusion in the architectural stuff here since the attempted inclusion of logback

// Explanationish: https://logback.qos.ch/manual/appenders.html
// TODO code mostly generated by sonnet 3.5

// TODO can this be simplified further?

//TODO split this file / rename

// via sonnet
 data class LogEntry (
    val loggerName: String,
    // val marker: Marker?, // We don't use markers I guess
    val level: Level, //TODO so the code currently assumes this ends up being an slf4j Level I guess
    val message: String,
    val throwable: Throwable?, //TODO will this lead to memory leaks? //TODO had some trouble figiuring out the relationship between using the slf4j api and logback
    val timestamp: Long
)

fun LogEntry.format(): String { //TODO stack trace etc
    val timestamp = java.time.Instant.ofEpochMilli(timestamp)
        .atZone(java.time.ZoneId.systemDefault())
        .format(java.time.format.DateTimeFormatter.ISO_LOCAL_TIME)

    return buildString {
        append("$timestamp [${level.levelStr}] [${loggerName.split(".").last()}] $message")
        if (throwable != null) {
            append(" - ${throwable.javaClass} - ${throwable.message}")
        }
    }
}

// Thread-safe log storage, partly via sonnet
// We want to store all logs and yield efficient append updates for subscribers.
// So we use a flow, retain and replay all logs when a new subscriber connects.
// TODO regarding the UI side of things, with the current implementation (do?) we end up with several full copies of the log in memory?
//   the one located here, and also the mutableStateOf in the UI with the lazyColumn, at least?
//   is there some approach where our object here is an observable but the object itself is reused?
//   Ok so basically this is like/what I really want is having this be the backing Model for the LazyColumn(mvc).
class LogBuffer {
    //TODO and I don't like singletons anyway.
    //NOTE: so the issue, right, is that with the xml config, the appender needs to be set up without programmatic access so it needs some way to get the buffer, and then i also need that buffer somewhere else.
    companion object { //TODO set it up for DI instead? or use programmatic logback configuration to pass the log buffer to the constructor, and expose it some other way to the ui stuff.
        // Using lazy with thread safety
        val INSTANCE: LogBuffer by lazy(LazyThreadSafetyMode.SYNCHRONIZED) { LogBuffer() }
    }

    private val _entries = MutableSharedFlow<LogEntry>(replay = Int.MAX_VALUE)
    val entries = _entries.asSharedFlow()
    //val entries: List<LogEntry> get() = _entries.toList()  //TODO efficiency or something, we will want to get updates from UI code

    fun append(entry: LogEntry) { //TODO do I need this given the slf4j / logback stuf??
        if(!_entries.tryEmit(entry)) { // docs say thread safe
            throw IllegalStateException("Could not append to LogBuffer, it's not ready to receive.")
        }
    }
}
class VisualLoggerAppender : AppenderBase<ILoggingEvent>() { //TODO reportedly thread safe?
    private val buffer = LogBuffer.INSTANCE
    val logs = buffer.entries

    override fun append(event: ILoggingEvent) {
        buffer.append(
            LogEntry(
            loggerName = event.loggerName,
            level = event.level,
            message = event.formattedMessage,
            // TODO proper conversion of stack trace, suppressed, etc
            // Need to convert IThrowableProxy to Throwable
            throwable = when (event.throwableProxy) {
                null -> null
                else -> RuntimeException(event.throwableProxy.message)
            },
            timestamp = event.timeStamp
        )
        )
    }
}