package com.example.comp.ui.util.logging

import ch.qos.logback.classic.spi.ILoggingEvent
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.asSharedFlow
import org.slf4j.ILoggerFactory
import org.slf4j.IMarkerFactory
import org.slf4j.Logger
import org.slf4j.Marker
import org.slf4j.event.KeyValuePair
import org.slf4j.event.Level
import org.slf4j.event.LoggingEvent
import org.slf4j.helpers.LegacyAbstractLogger
import org.slf4j.helpers.NOPMDCAdapter
import org.slf4j.spi.MDCAdapter
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentMap

//TODO there's some confusion in the architectural stuff here since the attempted inclusion of logback

// Explanationish: https://www.slf4j.org/faq.html#slf4j_compatible
// xref https://github.com/qos-ch/slf4j/tree/master/slf4j-simple/src/main/java/org/slf4j/simple for slf4j-simple
// TODO code mostly generated by sonnet 3.5 or based off slf4j-simple
// TODO https://www.slf4j.org/codes.html#replay ?
// TODO https://www.slf4j.org/codes.html#substituteLogger ?

// TODO can this be simplified further?

// TODO also forward to standard android logger, or have that set up in the app logging configuration (probably better)
class VisualLoggerAdapter(name : String) : LegacyAbstractLogger() {
    private val buffer = LogBuffer()
    val logs get() = buffer.entries
    init {
        this.name = name
    }
    override fun isTraceEnabled(): Boolean = true
    override fun isDebugEnabled(): Boolean = true
    override fun isInfoEnabled(): Boolean = true
    override fun isWarnEnabled(): Boolean = true
    override fun isErrorEnabled(): Boolean = true
    override fun getFullyQualifiedCallerName(): String? = null // TODO IDK, this is what Simple uses.

    override fun handleNormalizedLoggingCall(
        level: Level?,
        marker: Marker?,
        messagePattern: String?,
        arguments: Array<out Any>?,
        throwable: Throwable?
    ) {
        buffer.append(LogEntry(this.name, level, message, throwable, System.currentTimeMillis()))
    }
}


// Based off slf4j-simple SimpleLoggerFactory
// TODO IDK if null logger names are permitted or can happen so we're just going to assume non-null for now as it simplifies things
// Sonnet had a suggestion of null ?: "ROOT"
class VisualLoggerFactory private constructor(): ILoggerFactory {
    // https://medium.com/@ZahraHeydari/singleton-pattern-in-kotlin-b09380c53b14

    //TODO how does slf4j-simple deal with making sure this isn't duplicated?
    // or is the factory/provider kept track of by slf4j?
    companion object {
        val INSTANCE: VisualLoggerFactory by lazy(LazyThreadSafetyMode.SYNCHRONIZED) { VisualLoggerFactory() }
    }

    private val loggers : ConcurrentMap<String, VisualLoggerAdapter> = ConcurrentHashMap()
    override fun getLogger(name: String): Logger {
        return loggers.computeIfAbsent(name) { VisualLoggerAdapter(name) } //TODO pass name?
    }
}

// Based off SimpleServiceProvider
class VisualLoggerProvider : org.slf4j.spi.SLF4JServiceProvider {
    companion object { //TODO but why?
        const val REQUESTED_API_VERSION : String = "2.0.99"
    }

    private lateinit var loggerFactory : ILoggerFactory
    private lateinit var markerFactory: IMarkerFactory
    private lateinit var mdcAdapter: MDCAdapter

    override fun getLoggerFactory(): ILoggerFactory = loggerFactory
    override fun getMarkerFactory(): IMarkerFactory = markerFactory
    override fun getMDCAdapter(): MDCAdapter = mdcAdapter
    override fun getRequestedApiVersion(): String = REQUESTED_API_VERSION

    // Docs say the following, so presumabyl don't need to worry about thread-safety; "
    //   Initialize the logging back-end.
    //   WARNING: This method is intended to be called once by LoggerFactory class and from nowhere else.
    //   "
    override fun initialize() {
        loggerFactory = VisualLoggerFactory.INSTANCE
        markerFactory = org.slf4j.helpers.BasicMarkerFactory()
        mdcAdapter = NOPMDCAdapter()
    }
}

// via sonnet
 data class LogEntry (
    val loggerName: String,
    // val marker: Marker?, // We don't use markers I guess
    val level: Level, //TODO so the code currently assumes this ends up being an slf4j Level I guess
    val message: String,
    val throwable: Throwable?, //TODO will this lead to memory leaks? //TODO had some trouble figiuring out the relationship between using the slf4j api and logback
    val timestamp: Long
) {
    companion object {
         fun fromSlf4jEvent(event: LoggingEvent): LogEntry {
            return LogEntry(
                level = event.level,
                loggerName = event.loggerName,
                message = event.message,
                throwable = event.throwable,
                timestamp = event.timeStamp
            )
        }
    }
 }

// TODO should I even need this? Shouldn't there be some kind of adapter to slf4j, or just get an existing interface implementer or something?
// via sonnet, TODO didn't review, TODO made stuff nullable, but what's correct?
// TODO no idea what half of these do, and they seem undocumented?
class LogbackToSlf4jEvent(private val event: ILoggingEvent) : LoggingEvent {
    // TODO slf4j constants seem to match logback constants, but IDK what the correct way to do this is
    // https://www.slf4j.org/api/src-html/org/slf4j/event/Level.html refers to org.slf4j.event.EventConstants,
    // https://github.com/tony19/logback-android/blob/main/logback-android/src/main/java/ch/qos/logback/classic/Level.java references the
    //   slf4j locationawarelogger interface: https://www.slf4j.org/api/org/slf4j/spi/LocationAwareLogger.html
    override fun getLevel(): Level =
        Level.intToLevel(ch.qos.logback.classic.Level.toLocationAwareLoggerInteger(event.level))

    override fun getLoggerName(): String = event.loggerName
    override fun getMessage(): String = event.message
    override fun getArguments(): List<Any>? = event.argumentArray?.toList()
    override fun getArgumentArray(): Array<Any?>? = event.argumentArray
    override fun getMarkers(): List<Marker>? = event.markers?.toList()

    override fun getKeyValuePairs(): List<KeyValuePair> =
        event.mdcPropertyMap.map { (key, value) -> KeyValuePair(key, value) }
    override fun getThreadName(): String = event.threadName
    override fun getTimeStamp(): Long = event.timeStamp

    override fun getThrowable(): Throwable? { //TODO
        val proxy = event.throwableProxy ?: return null
        // Need to convert IThrowableProxy to Throwable
        // TODO proper conversion of stack trace, suppressed, etc
        return RuntimeException(proxy.message)
    }
}


// Thread-safe log storage, partly via sonnet
// We want to store all logs and yield efficient append updates for subscribers.
// So we use a flow, retain and replay all logs when a new subscriber connects.
// TODO regarding the UI side of things, with the current implementation (do?) we end up with several full copies of the log in memory?
//   the one located here, and also the mutableStateOf in the UI with the lazyColumn, at least?
//   is there some approach where our object here is an observable but the object itself is reused?
//   Ok so basically this is like/what I really want is having this be the backing Model for the LazyColumn(mvc).
class LogBuffer {
    private val _entries = MutableSharedFlow<LogEntry>(replay = Int.MAX_VALUE)
    val entries = _entries.asSharedFlow()
    //val entries: List<LogEntry> get() = _entries.toList()  //TODO efficiency or something, we will want to get updates from UI code

    fun append(entry: LogEntry) { //TODO do I need this given the slf4j / logback stuf??
        if(!_entries.tryEmit(entry)) { // docs say thread safe
            throw IllegalStateException("Could not append to LogBuffer, it's not ready to receive.")
        }
    }
}